<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON TACTICS: ULTIMATE EDITION</title>
    <style>
        :root {
            --bg: #020617;
            --panel: rgba(30, 41, 59, 0.95);
            --primary: #38bdf8;
            --accent-x: #fb7185;
            --accent-o: #34d399;
            --text: #f1f5f9;
        }

        * { 
            box-sizing: border-box; margin: 0; padding: 0; 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        body {
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow-x: hidden;
        }

        .wrapper {
            width: 100%;
            max-width: 420px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            letter-spacing: 4px;
            font-size: 1.8rem;
            text-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            font-weight: 900;
        }

        .status-bar {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--primary);
            text-transform: uppercase;
            border: 1px solid rgba(255,255,255,0.1);
            min-height: 45px;
        }

        /* –ù–ê–°–¢–†–û–ô–ö–ò */
        .settings-container {
            background: var(--panel);
            border-radius: 20px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .settings-container.hidden { display: none; }

        .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
        .row-label { font-size: 0.7rem; color: #94a3b8; font-weight: 900; text-transform: uppercase; width: 75px; }

        .group { display: flex; flex: 1; background: rgba(0,0,0,0.3); padding: 4px; border-radius: 10px; }
        .opt-btn {
            flex: 1; padding: 10px 0; border: none; background: transparent;
            color: #64748b; font-weight: bold; cursor: pointer; border-radius: 7px;
            font-size: 0.8rem; transition: 0.2s;
        }
        .opt-btn.active { background: var(--primary); color: #020617; }
        .opt-btn:disabled { opacity: 0.1; cursor: not-allowed; }

        /* –°–ï–¢–ö–ê */
        .board-frame {
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex; align-items: center; justify-content: center;
        }

        .board-grid {
            display: grid;
            width: 100%;
            height: 100%;
            gap: 10px;
            grid-template-columns: repeat(var(--cols, 3), 1fr);
            grid-template-rows: repeat(var(--cols, 3), 1fr);
        }

        .cell {
            background: #0f172a;
            border-radius: 14px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; aspect-ratio: 1 / 1;
            border: 1px solid rgba(255,255,255,0.05);
            transition: 0.15s;
            position: relative;
        }

        .cell:active { transform: scale(0.92); }
        .cell span { font-size: var(--fs, 3rem); font-weight: 900; }
        .cell.x span { color: var(--accent-x); text-shadow: 0 0 15px var(--accent-x); }
        .cell.o span { color: var(--accent-o); text-shadow: 0 0 15px var(--accent-o); }

        .cell.winner { background: var(--primary); box-shadow: 0 0 20px var(--primary); }
        .cell.winner span { color: #020617; text-shadow: none; }
        
        .cell.hint { background: rgba(251, 191, 36, 0.2); border: 2px solid #fbbf24; }

        /* –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø */
        .footer-btns { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        
        .btn {
            padding: 15px 5px; border: none; border-radius: 14px;
            font-weight: 900; cursor: pointer; text-transform: uppercase;
            font-size: 0.8rem; transition: 0.2s;
        }

        .btn-play { background: var(--primary); color: #020617; grid-column: span 1; }
        .btn-side { background: #334155; color: white; }
        .btn-hint { background: #475569; color: #fbbf24; }

        .btn:active { transform: translateY(2px); }
        .locked { pointer-events: none; }

    </style>
</head>
<body>

<div class="wrapper">
    <h1>NEON TACTICS</h1>

    <div class="status-bar" id="status">–ì–û–¢–û–í –ö –¢–†–£–î–£</div>

    <div class="settings-container" id="menu">
        <div class="row">
            <span class="row-label">–ü–û–õ–ï</span>
            <div class="group" id="set-size">
                <button class="opt-btn active" onclick="config('size', 3, this)">3x3</button>
                <button class="opt-btn" onclick="config('size', 4, this)">4x4</button>
                <button class="opt-btn" onclick="config('size', 5, this)">5x5</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–£–°–õ–û–í–ò–ï</span>
            <div class="group" id="set-win">
                <button class="opt-btn active" data-v="3" onclick="config('win', 3, this)">3</button>
                <button class="opt-btn" data-v="4" onclick="config('win', 4, this)">4</button>
                <button class="opt-btn" data-v="5" onclick="config('win', 5, this)">5</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–ú–û–ó–ì–ò</span>
            <div class="group" id="set-diff">
                <button class="opt-btn" onclick="config('diff', 'easy', this)">–ò–ó–ò</button>
                <button class="opt-btn" onclick="config('diff', 'norm', this)">–ù–û–†–ú</button>
                <button class="opt-btn active" onclick="config('diff', 'god', this)">–ë–û–ì</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–†–ï–ñ–ò–ú</span>
            <div class="group" id="set-pro">
                <button class="opt-btn active" onclick="config('pro', false, this)">–í–´–ö–õ</button>
                <button class="opt-btn" onclick="config('pro', true, this)">PRO</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–Ø –ò–ì–†–ê–Æ –ó–ê</span>
            <div class="group" id="set-side">
                <button class="opt-btn active" onclick="config('playerSide', 'X', this)">X</button>
                <button class="opt-btn" onclick="config('playerSide', 'O', this)">O</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–•–û–î–ò–¢</span>
            <div class="group" id="set-start">
                <button class="opt-btn active" onclick="config('start', 'p', this)">–Ø</button>
                <button class="opt-btn" onclick="config('start', 'b', this)">–ë–û–¢</button>
            </div>
        </div>
    </div>

    <div class="board-frame">
        <div class="board-grid" id="board"></div>
    </div>

    <div class="footer-btns">
        <button class="btn btn-side" onclick="toggleMenu()">‚öôÔ∏è –û–ü–¶–ò–ò</button>
        <button class="btn btn-hint" onclick="getHint()">üí°</button>
        <button class="btn btn-play" onclick="initGame()">–ò–ì–†–ê–¢–¨</button>
    </div>
</div>

<script>
    let settings = { size: 3, win: 3, diff: 'god', pro: false, playerSide: 'X', start: 'p' };
    let session = { board: [], active: false, turn: 'X', botSide: 'O', winLines: [] };

    function config(key, val, el) {
        settings[key] = val;
        [...el.parentElement.children].forEach(b => b.classList.remove('active'));
        el.classList.add('active');

        if (key === 'size') {
            const winBtns = document.getElementById('set-win').children;
            [...winBtns].forEach(b => {
                const v = parseInt(b.dataset.v);
                if (v > settings.size) {
                    b.disabled = true;
                    b.classList.remove('active');
                } else {
                    b.disabled = false;
                    if (settings.win === v) b.classList.add('active');
                }
            });
            if (settings.win > settings.size) {
                settings.win = settings.size;
                [...winBtns].find(b => parseInt(b.dataset.v) === settings.size).classList.add('active');
            }
            drawEmpty();
        }
    }

    function toggleMenu() { document.getElementById('menu').classList.toggle('hidden'); }

    function drawEmpty() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        b.style.setProperty('--cols', settings.size);
        const fs = settings.size === 3 ? '3.5rem' : settings.size === 4 ? '2.5rem' : '1.8rem';
        b.style.setProperty('--fs', fs);
        for(let i=0; i<settings.size*settings.size; i++) {
            const c = document.createElement('div');
            c.className = 'cell';
            c.innerHTML = '<span></span>';
            b.appendChild(c);
        }
    }

    function initGame() {
        session.active = true;
        session.board = Array(settings.size * settings.size).fill(null);
        session.botSide = settings.playerSide === 'X' ? 'O' : 'X';
        session.turn = settings.start === 'p' ? settings.playerSide : session.botSide;
        session.winLines = generateLines(settings.size, settings.win);
        document.getElementById('menu').classList.add('hidden');
        render();
        checkTurn();
    }

    function checkTurn() {
        if (!session.active) return;
        if (session.turn === session.botSide) {
            setStatus("–ë–û–¢ –î–£–ú–ê–ï–¢ (" + session.botSide + ")...");
            document.getElementById('board').classList.add('locked');
            setTimeout(botMove, 600);
        } else {
            setStatus("–¢–í–û–ô –•–û–î (" + settings.playerSide + ")");
            document.getElementById('board').classList.remove('locked');
        }
    }

    function render() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        session.board.forEach((val, i) => {
            const c = document.createElement('div');
            c.className = 'cell' + (val ? ' ' + val.toLowerCase() : '');
            c.innerHTML = `<span>${val || ''}</span>`;
            c.onclick = () => playerMove(i);
            b.appendChild(c);
        });
    }

    function playerMove(i) {
        if (!session.active || session.board[i]) return;
        doMove(i, settings.playerSide);
        if (session.active) checkTurn();
    }

    function doMove(i, sym) {
        session.board[i] = sym;
        render();
        const win = checkWin(session.board, sym);
        if (win) {
            session.active = false;
            win.forEach(idx => document.getElementById('board').children[idx].classList.add('winner'));
            setStatus(sym === settings.playerSide ? "–¢–´ –ü–û–ë–ï–î–ò–õ!" : "–ë–û–¢ –í–´–ò–ì–†–ê–õ");
            return;
        }
        if (!session.board.includes(null)) {
            session.active = false;
            setStatus("–ù–ò–ß–¨–Ø");
            return;
        }
        session.turn = session.turn === 'X' ? 'O' : 'X';
    }

    function botMove() {
        if (!session.active) return;
        let idx = (settings.diff === 'god') ? findGodMove() : findBestLogic();
        if (settings.diff === 'easy' && Math.random() < 0.7) idx = randomEmpty();
        doMove(idx, session.botSide);
        checkTurn();
    }

    function findBestLogic() {
        for(let i=0; i<session.board.length; i++) {
            if(!session.board[i]) {
                let b = [...session.board]; b[i] = session.botSide;
                if(checkWin(b, session.botSide)) return i;
            }
        }
        for(let i=0; i<session.board.length; i++) {
            if(!session.board[i]) {
                let b = [...session.board]; b[i] = settings.playerSide;
                if(checkWin(b, settings.playerSide)) return i;
            }
        }
        return randomEmpty();
    }

    function findGodMove() {
        // –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ú–æ–∂–µ–º –ª–∏ –º—ã –≤—ã–∏–≥—Ä–∞—Ç—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å?
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞ (–∫—Ç–æ —Å–µ–π—á–∞—Å —Ö–æ–¥–∏—Ç)
        for(let i=0; i<session.board.length; i++) {
            if(!session.board[i]) {
                let b = [...session.board]; b[i] = session.turn; 
                if(checkWin(b, session.turn)) return i;
            }
        }

        // –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ú–æ–∂–µ—Ç –ª–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫ –≤—ã–∏–≥—Ä–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º —Ö–æ–¥–æ–º? –ë–ª–æ–∫–∏—Ä—É–µ–º.
        let opponent = session.turn === 'X' ? 'O' : 'X';
        for(let i=0; i<session.board.length; i++) {
            if(!session.board[i]) {
                let b = [...session.board]; b[i] = opponent;
                if(checkWin(b, opponent)) return i;
            }
        }

        // –ï—Å–ª–∏ –ø–æ–ª–µ 3x3 ‚Äî –≤–∫–ª—é—á–∞–µ–º –∏–¥–µ–∞–ª—å–Ω—ã–π –ø—Ä–æ—Å—á–µ—Ç
        if (settings.size === 3) return minimax(session.board, 0, true, -Infinity, Infinity).index;
        
        // PRO –õ–û–ì–ò–ö–ê (–í–ï–°–ê) –¥–ª—è 4x4 –∏ 5x5
        if (settings.pro) {
            let weights = Array(session.board.length).fill(0);
            session.winLines.forEach(line => {
                let countBot = line.filter(idx => session.board[idx] === session.botSide).length;
                let countPlayer = line.filter(idx => session.board[idx] === settings.playerSide).length;
                if (countBot > 0 && countPlayer > 0) return; 
                line.forEach(idx => { if (!session.board[idx]) weights[idx] += (1 + countBot + countPlayer); });
            });
            let maxWeight = -1, bestMoves = [];
            weights.forEach((w, i) => {
                if (session.board[i]) return;
                if (w > maxWeight) { maxWeight = w; bestMoves = [i]; }
                else if (w === maxWeight) bestMoves.push(i);
            });
            return bestMoves[Math.floor(Math.random() * bestMoves.length)];
        }

        // –û–±—ã—á–Ω–∞—è –ª–æ–≥–∏–∫–∞ (–µ—Å–ª–∏ PRO –≤—ã–∫–ª) - —Ü–µ–Ω—Ç—Ä
        const center = Math.floor(session.board.length / 2);
        if (!session.board[center]) return center;
        return randomEmpty();
    }

    function minimax(board, depth, isMax, alpha, beta) {
        const avail = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
        if (checkWin(board, settings.playerSide)) return { score: -10 + depth };
        if (checkWin(board, session.botSide)) return { score: 10 - depth };
        if (avail.length === 0) return { score: 0 };

        let moves = [];
        for (let i = 0; i < avail.length; i++) {
            let move = { index: avail[i] };
            board[avail[i]] = isMax ? session.botSide : settings.playerSide;
            let res = minimax(board, depth + 1, !isMax, alpha, beta);
            move.score = res.score;
            board[avail[i]] = null;
            moves.push(move);
            if (isMax) {
                alpha = Math.max(alpha, move.score);
                if (beta <= alpha) break;
            } else {
                beta = Math.min(beta, move.score);
                if (beta <= alpha) break;
            }
        }
        let best;
        if (isMax) {
            let bestScore = -Infinity;
            for (let i = 0; i < moves.length; i++) {
                if (moves[i].score > bestScore) { bestScore = moves[i].score; best = i; }
            }
        } else {
            let bestScore = Infinity;
            for (let i = 0; i < moves.length; i++) {
                if (moves[i].score < bestScore) { bestScore = moves[i].score; best = i; }
            }
        }
        return moves[best];
    }

    function randomEmpty() {
        const empty = session.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
        return empty[Math.floor(Math.random() * empty.length)];
    }

    function getHint() {
        if (!session.active) return;
        
        // –ü–æ–¥—Å–∫–∞–∑–∫–∞ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∞–º—É—é —Å–∏–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É
        const idx = findGodMove();
        
        const cell = document.getElementById('board').children[idx];
        cell.classList.add('hint');
        setTimeout(() => cell.classList.remove('hint'), 800);
    }

    function generateLines(s, w) {
        let lines = [];
        for (let r = 0; r < s; r++) {
            for (let c = 0; c <= s - w; c++) {
                let l = []; for (let k = 0; k < w; k++) l.push(r * s + (c + k));
                lines.push(l);
            }
        }
        for (let c = 0; c < s; c++) {
            for (let r = 0; r <= s - w; r++) {
                let l = []; for (let k = 0; k < w; k++) l.push((r + k) * s + c);
                lines.push(l);
            }
        }
        for (let r = 0; r <= s - w; r++) {
            for (let c = 0; c <= s - w; c++) {
                let l1 = []; for (let k = 0; k < w; k++) l1.push((r + k) * s + (c + k));
                lines.push(l1);
                let l2 = []; for (let k = 0; k < w; k++) l2.push((r + k) * s + (c + w - 1 - k));
                lines.push(l2);
            }
        }
        return lines;
    }

    function checkWin(b, sym) {
        for (let line of session.winLines) {
            if (line.every(i => b[i] === sym)) return line;
        }
        return null;
    }

    function setStatus(t) { document.getElementById('status').innerText = t; }

    drawEmpty();
</script>
</body>
</html>
