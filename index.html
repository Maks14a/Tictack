<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON TACTICS</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(30, 41, 59, 0.7);
            --primary: #38bdf8;       /* Light Blue */
            --accent-x: #f472b6;      /* Pink */
            --accent-o: #2dd4bf;      /* Teal */
            --text: #f1f5f9;
            --grid-size: 3;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: radial-gradient(circle at top, #1e293b, #0f172a);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        h1 {
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 800;
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        /* --- Settings Panel --- */
        .settings-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            font-weight: 600;
        }

        .toggle-group {
            display: flex;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 10px;
            padding: 4px;
            gap: 4px;
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: #64748b;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .toggle-btn:hover {
            color: #cbd5e1;
            background: rgba(255,255,255,0.05);
        }

        .toggle-btn.active {
            background: var(--primary);
            color: #0f172a;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }

        /* Checkbox slider for Optimization */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(15, 23, 42, 0.6);
            padding: 12px;
            border-radius: 10px;
        }

        .switch-label {
            font-size: 0.95rem;
            color: #cbd5e1;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #334155;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(24px); }

        /* --- Game Board --- */
        .status-bar {
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            min-height: 24px;
            color: #e2e8f0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            gap: 10px;
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 20px;
            width: 100%;
            aspect-ratio: 1/1;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
            position: relative;
        }

        .cell {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            
            /* Dynamic Font Size */
            font-size: calc(280px / var(--grid-size)); 
        }

        /* Mobile tweaks */
        @media (max-width: 480px) {
            .cell { font-size: calc(85vw / var(--grid-size) - 15px); }
        }

        .cell:hover { transform: scale(0.98); background: rgba(51, 65, 85, 0.9); }
        
        .cell.x { color: var(--accent-x); text-shadow: 0 0 15px var(--accent-x); }
        .cell.o { color: var(--accent-o); text-shadow: 0 0 15px var(--accent-o); }

        .cell.winner {
            background: rgba(255, 255, 255, 0.1);
            animation: pulse-win 1.5s infinite;
        }
        
        @keyframes pulse-win {
            0%, 100% { box-shadow: 0 0 15px var(--primary); }
            50% { box-shadow: 0 0 30px var(--primary); }
        }

        .cell.hint {
            border: 2px dashed #fcd34d;
            background: rgba(252, 211, 77, 0.1);
        }

        /* --- Controls --- */
        .controls {
            display: flex;
            gap: 15px;
            width: 100%;
        }

        .btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.1s, filter 0.2s;
        }

        .btn:active { transform: translateY(2px); }

        .btn-start {
            background: linear-gradient(135deg, #0ea5e9, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
        }

        .btn-hint {
            background: #334155;
            color: #94a3b8;
            flex: 0.4;
        }
        .btn-hint:hover { color: #fcd34d; }

        .board.disabled { pointer-events: none; opacity: 0.9; }

    </style>
</head>
<body>

<div class="container">
    <h1>Neon Tactics</h1>

    <div class="settings-panel">
        
        <div class="setting-row">
            <span class="setting-label">Размер поля</span>
            <div class="toggle-group" id="size-options">
                <button class="toggle-btn active" data-value="3">3x3</button>
                <button class="toggle-btn" data-value="4">4x4</button>
                <button class="toggle-btn" data-value="5">5x5</button>
            </div>
        </div>

        <div class="setting-row">
            <span class="setting-label">Условие победы (в ряд)</span>
            <div class="toggle-group" id="win-options">
                <button class="toggle-btn active" data-value="3">3</button>
                <button class="toggle-btn" data-value="4">4</button>
                <button class="toggle-btn" data-value="5">5</button>
            </div>
        </div>

        <div class="setting-row">
            <span class="setting-label">Интеллект бота</span>
            <div class="toggle-group" id="diff-options">
                <button class="toggle-btn" data-value="easy">Глупый</button>
                <button class="toggle-btn" data-value="medium">Норм</button>
                <button class="toggle-btn active" data-value="hard">Бог</button>
            </div>
        </div>

        <div class="setting-row" style="flex-direction: row; gap: 10px;">
            <div style="flex: 1;">
                <span class="setting-label">Вы играете за</span>
                <div class="toggle-group" id="symbol-options">
                    <button class="toggle-btn active" data-value="X">X</button>
                    <button class="toggle-btn" data-value="O">O</button>
                </div>
            </div>
            <div style="flex: 1;">
                <span class="setting-label">Первый ход</span>
                <div class="toggle-group" id="starter-options">
                    <button class="toggle-btn active" data-value="player">Я</button>
                    <button class="toggle-btn" data-value="bot">Бот</button>
                </div>
            </div>
        </div>

        <div class="switch-container">
            <span class="switch-label">⚡ Оптимизация (Быстрый ход)</span>
            <label class="switch">
                <input type="checkbox" id="opt-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>

    </div>

    <div class="status-bar" id="status">Нажми СТАРТ для начала</div>
    
    <div class="board" id="board"></div>

    <div class="controls">
        <button class="btn btn-start" id="start-btn">Старт / Сброс</button>
        <button class="btn btn-hint" id="hint-btn">?</button>
    </div>
</div>

<script>
    // --- Логика Игры ---
    const GameState = {
        board: [],
        size: 3,
        winLength: 3,
        currentPlayer: null, // 'X' или 'O'
        isActive: false,
        winner: null,
        winLine: []
    };

    // --- Настройки ---
    const Settings = {
        size: 3,
        winLength: 3,
        difficulty: 'hard',
        userSymbol: 'X',
        botSymbol: 'O',
        starter: 'player', // 'player' или 'bot'
        optimized: true
    };

    // --- Искусственный Интеллект ---
    const AI = {
        getBestMove(board, symbol) {
            // 1. Уровень сложности: Вероятность ошибки
            let errorChance = 0;
            if (Settings.difficulty === 'easy') errorChance = 0.8; // 80% тупит
            else if (Settings.difficulty === 'medium') errorChance = 0.3; // 30% тупит

            // Если бот решил "тупить", делаем случайный ход
            if (Math.random() < errorChance) {
                const empty = this.getEmptyCells(board);
                return empty[Math.floor(Math.random() * empty.length)];
            }

            // 2. Хардкор режим: Minimax
            // Определяем максимальную глубину просчета
            let maxDepth = 100;
            if (Settings.optimized) {
                // Если включена оптимизация, режем глубину
                if (Settings.size === 3) maxDepth = 9;
                else if (Settings.size === 4) maxDepth = 3;
                else maxDepth = 2; // Для 5x5 очень мелко
            } else {
                // Если оптимизация ВЫКЛ, бот думает дольше
                if (Settings.size === 3) maxDepth = 9;
                else if (Settings.size === 4) maxDepth = 5;
                else maxDepth = 3;
            }

            // Первый ход бота на пустом поле - всегда центр (оптимизация)
            const emptyCells = this.getEmptyCells(board);
            if (emptyCells.length === board.length) {
                return Math.floor(board.length / 2);
            }
            if (emptyCells.length === board.length - 1 && Settings.size >= 4) {
                 // На больших полях если игрок сходил не в центр, бот занимает центр
                 const center = Math.floor(board.length / 2);
                 if (board[center] === null) return center;
            }

            return this.minimax(board, 0, true, -Infinity, Infinity, symbol, maxDepth).index;
        },

        minimax(board, depth, isMaximizing, alpha, beta, playerSymbol, maxDepthLimit) {
            const opponentSymbol = playerSymbol === 'X' ? 'O' : 'X';
            
            // Проверка терминальных состояний
            if (this.checkWin(board, playerSymbol)) return { score: 1000 - depth };
            if (this.checkWin(board, opponentSymbol)) return { score: -1000 + depth };
            
            const availSpots = this.getEmptyCells(board);
            if (availSpots.length === 0 || depth >= maxDepthLimit) {
                return { score: this.evaluateBoard(board, playerSymbol, opponentSymbol) };
            }

            if (isMaximizing) {
                let bestScore = -Infinity;
                let bestMove = -1;
                for (let i = 0; i < availSpots.length; i++) {
                    const idx = availSpots[i];
                    board[idx] = playerSymbol;
                    const result = this.minimax(board, depth + 1, false, alpha, beta, playerSymbol, maxDepthLimit);
                    board[idx] = null;
                    if (result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = idx;
                    }
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) break;
                }
                return { score: bestScore, index: bestMove };
            } else {
                let bestScore = Infinity;
                let bestMove = -1;
                for (let i = 0; i < availSpots.length; i++) {
                    const idx = availSpots[i];
                    board[idx] = opponentSymbol;
                    const result = this.minimax(board, depth + 1, true, alpha, beta, playerSymbol, maxDepthLimit);
                    board[idx] = null;
                    if (result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = idx;
                    }
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) break;
                }
                return { score: bestScore, index: bestMove };
            }
        },

        getEmptyCells(board) {
            const cells = [];
            for (let i = 0; i < board.length; i++) {
                if (board[i] === null) cells.push(i);
            }
            return cells;
        },

        // Эвристическая оценка (когда не дошли до конца игры)
        evaluateBoard(board, player, opponent) {
            let score = 0;
            const lines = getAllLines(Settings.size, Settings.winLength);
            
            for (let line of lines) {
                let pCount = 0;
                let oCount = 0;
                for (let idx of line) {
                    if (board[idx] === player) pCount++;
                    else if (board[idx] === opponent) oCount++;
                }
                if (pCount > 0 && oCount === 0) score += Math.pow(10, pCount);
                if (oCount > 0 && pCount === 0) score -= Math.pow(10, oCount);
            }
            return score;
        },

        // Упрощенная проверка победы для AI (быстрая)
        checkWin(board, sym) {
            const lines = getAllLines(Settings.size, Settings.winLength);
            for (let line of lines) {
                if (line.every(idx => board[idx] === sym)) return true;
            }
            return false;
        }
    };

    // --- Кэширование линий (оптимизация) ---
    let cachedLines = [];
    let lastCacheKey = '';

    function getAllLines(size, winLen) {
        const key = `${size}-${winLen}`;
        if (lastCacheKey === key && cachedLines.length > 0) return cachedLines;

        const lines = [];
        // Rows
        for (let r = 0; r < size; r++) {
            for (let c = 0; c <= size - winLen; c++) {
                const line = [];
                for (let k = 0; k < winLen; k++) line.push(r * size + c + k);
                lines.push(line);
            }
        }
        // Cols
        for (let c = 0; c < size; c++) {
            for (let r = 0; r <= size - winLen; r++) {
                const line = [];
                for (let k = 0; k < winLen; k++) line.push((r + k) * size + c);
                lines.push(line);
            }
        }
        // Diagonals
        for (let r = 0; r <= size - winLen; r++) {
            for (let c = 0; c <= size - winLen; c++) {
                const line = [];
                for (let k = 0; k < winLen; k++) line.push((r + k) * size + c + k);
                lines.push(line);
            }
        }
        // Anti-Diagonals
        for (let r = 0; r <= size - winLen; r++) {
            for (let c = winLen - 1; c < size; c++) {
                const line = [];
                for (let k = 0; k < winLen; k++) line.push((r + k) * size + c - k);
                lines.push(line);
            }
        }

        lastCacheKey = key;
        cachedLines = lines;
        return lines;
    }

    // --- UI Logic ---
    const UI = {
        init() {
            this.setupListeners();
            this.renderEmptyBoard();
        },

        setupListeners() {
            // Кнопки настроек
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const group = btn.parentElement;
                    group.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.updateSettings();
                });
            });

            // Галочка оптимизации
            document.getElementById('opt-toggle').addEventListener('change', this.updateSettings.bind(this));

            // Кнопка Старт
            document.getElementById('start-btn').addEventListener('click', () => this.startGame());

            // Кнопка Подсказка
            document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
        },

        updateSettings() {
            Settings.size = parseInt(document.querySelector('#size-options .active').dataset.value);
            Settings.winLength = parseInt(document.querySelector('#win-options .active').dataset.value);
            Settings.difficulty = document.querySelector('#diff-options .active').dataset.value;
            Settings.userSymbol = document.querySelector('#symbol-options .active').dataset.value;
            Settings.botSymbol = Settings.userSymbol === 'X' ? 'O' : 'X';
            Settings.starter = document.querySelector('#starter-options .active').dataset.value;
            Settings.optimized = document.getElementById('opt-toggle').checked;

            // Валидация: WinLength не может быть больше Size
            if (Settings.winLength > Settings.size) {
                // Если условие победы больше поля, сбрасываем на макс. возможное
                Settings.winLength = Settings.size;
                // Визуальное обновление кнопок
                document.querySelectorAll('#win-options .toggle-btn').forEach(b => {
                    b.classList.remove('active');
                    if(parseInt(b.dataset.value) === Settings.size) b.classList.add('active');
                });
            }

            // Обновляем CSS Grid
            document.documentElement.style.setProperty('--grid-size', Settings.size);
            
            // Если игра не идет, перерисовываем пустую доску
            if (!GameState.isActive) {
                this.renderEmptyBoard();
            }
        },

        renderEmptyBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            boardEl.classList.remove('disabled');
            const total = Settings.size * Settings.size;
            
            for(let i=0; i<total; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                boardEl.appendChild(cell);
            }
            document.getElementById('status').textContent = 'Нажми СТАРТ';
            document.getElementById('status').style.color = '#e2e8f0';
        },

        startGame() {
            // Считываем настройки в последний раз перед стартом
            this.updateSettings();

            // Инициализация состояния
            GameState.size = Settings.size;
            GameState.winLength = Settings.winLength;
            GameState.board = Array(Settings.size * Settings.size).fill(null);
            GameState.isActive = true;
            GameState.winner = null;
            GameState.winLine = [];
            
            // Кто ходит первым?
            GameState.currentPlayer = (Settings.starter === 'player') 
                ? Settings.userSymbol 
                : Settings.botSymbol;

            this.drawBoard();
            this.updateStatus();

            // Если начинает бот
            if (Settings.starter === 'bot') {
                this.processBotTurn();
            }
        },

        drawBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            boardEl.classList.remove('disabled');
            
            GameState.board.forEach((cell, i) => {
                const el = document.createElement('div');
                el.className = 'cell';
                if (cell) el.classList.add(cell.toLowerCase());
                el.textContent = cell || '';
                
                // Клик
                el.addEventListener('click', () => this.handleCellClick(i));
                
                // Подсветка победы
                if (GameState.winLine.includes(i)) el.classList.add('winner');
                
                boardEl.appendChild(el);
            });
        },

        handleCellClick(index) {
            if (!GameState.isActive) return;
            // Проверка: ход игрока?
            if (GameState.currentPlayer !== Settings.userSymbol) return;
            // Клетка свободна?
            if (GameState.board[index] !== null) return;

            // Ход игрока
            this.makeMove(index, Settings.userSymbol);

            // Если игра продолжается, запускаем бота
            if (GameState.isActive) {
                this.processBotTurn();
            }
        },

        makeMove(index, symbol) {
            GameState.board[index] = symbol;
            
            // Проверка победы
            if (this.checkWin(index, symbol)) {
                GameState.isActive = false;
                GameState.winner = symbol;
            } else if (!GameState.board.includes(null)) {
                GameState.isActive = false;
                GameState.winner = 'draw';
            } else {
                GameState.currentPlayer = (symbol === 'X') ? 'O' : 'X';
            }

            this.drawBoard();
            this.updateStatus();
        },

        checkWin(lastIdx, symbol) {
            const lines = getAllLines(GameState.size, GameState.winLength);
            for (let line of lines) {
                if (line.every(i => GameState.board[i] === symbol)) {
                    GameState.winLine = line;
                    return true;
                }
            }
            return false;
        },

        async processBotTurn() {
            const boardEl = document.getElementById('board');
            boardEl.classList.add('disabled'); // Блок кликов
            document.getElementById('status').textContent = 'Бот думает...';
            document.getElementById('status').style.color = '#94a3b8';

            // Небольшая задержка для реализма
            await new Promise(r => setTimeout(r, 400));

            // Запускаем вычисления (через setTimeout чтобы UI отрисовался)
            setTimeout(() => {
                const move = AI.getBestMove([...GameState.board], Settings.botSymbol);
                
                if (move !== -1 && GameState.board[move] === null) {
                    this.makeMove(move, Settings.botSymbol);
                }

                if (GameState.isActive) {
                    boardEl.classList.remove('disabled');
                }
            }, 10);
        },

        updateStatus() {
            const statusEl = document.getElementById('status');
            if (GameState.isActive) {
                if (GameState.currentPlayer === Settings.userSymbol) {
                    statusEl.textContent = `Ваш ход (${Settings.userSymbol})`;
                    statusEl.style.color = '#38bdf8';
                } else {
                    statusEl.textContent = `Ход бота (${Settings.botSymbol})`;
                    statusEl.style.color = '#94a3b8';
                }
            } else {
                if (GameState.winner === 'draw') {
                    statusEl.textContent = 'Ничья!';
                    statusEl.style.color = '#fff';
                } else {
                    const youWon = GameState.winner === Settings.userSymbol;
                    statusEl.textContent = youWon ? 'ПОБЕДА!' : 'ПОРАЖЕНИЕ';
                    statusEl.style.color = youWon ? '#38bdf8' : '#f472b6';
                }
            }
        },

        showHint() {
            if (!GameState.isActive || GameState.currentPlayer !== Settings.userSymbol) return;

            // Используем AI для поиска хода за игрока
            // Для подсказки всегда используем Hard (но с учетом текущей настройки оптимизации)
            const savedDiff = Settings.difficulty;
            Settings.difficulty = 'hard'; // Временно включаем мозг на максимум
            
            const hintMove = AI.getBestMove([...GameState.board], Settings.userSymbol);
            
            Settings.difficulty = savedDiff; // Возвращаем настройку

            if (hintMove !== undefined && hintMove !== -1) {
                const cells = document.querySelectorAll('.cell');
                cells[hintMove].classList.add('hint');
                setTimeout(() => cells[hintMove].classList.remove('hint'), 1500);
            }
        }
    };

    // Старт
    UI.init();
</script>

</body>
</html>
