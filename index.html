<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON TACTICS: EVOLVED</title>
    <style>
        :root {
            --bg-color: #0b1120;
            --panel-bg: rgba(30, 41, 59, 0.85);
            --primary: #0ea5e9;
            --accent-x: #f43f5e; /* Red-Pink */
            --accent-o: #10b981; /* Emerald */
            --text: #f8fafc;
            --grid-cols: 3;
            --cell-size: 0px; /* –í—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ JS */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            overflow: hidden; /* –£–±–∏—Ä–∞–µ–º —Å–∫—Ä–æ–ª–ª */
        }

        .container {
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            height: 100%;
            justify-content: center;
        }

        h1 {
            color: var(--primary);
            font-weight: 900;
            text-transform: uppercase;
            font-size: 1.8rem;
            text-shadow: 0 0 25px rgba(14, 165, 233, 0.6);
            letter-spacing: 2px;
            text-align: center;
            margin-bottom: 5px;
        }

        /* --- Settings --- */
        .settings-panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            padding: 15px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }

        .settings-panel.collapsed {
            max-height: 0;
            padding: 0;
            opacity: 0;
            margin: 0;
            border: none;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        
        .row-label {
            font-size: 0.85rem;
            color: #94a3b8;
            font-weight: 600;
            white-space: nowrap;
        }

        .toggle-group {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 3px;
            flex: 1;
        }

        .t-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: #64748b;
            padding: 6px 0;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .t-btn.active {
            background: var(--primary);
            color: #fff;
            box-shadow: 0 2px 10px rgba(14, 165, 233, 0.4);
        }

        /* --- Board Area --- */
        .game-wrapper {
            width: 100%;
            aspect-ratio: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), 1fr);
            gap: 8px;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.02);
            padding: 10px;
            border-radius: 16px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }

        .cell {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            cursor: pointer;
            position: relative;
            /* CRITICAL FIX: Overflow hidden prevents resizing bugs */
            overflow: hidden; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: background 0.2s, transform 0.1s;
        }

        .cell span {
            /* Font size is calculated in JS based on grid size */
            font-size: var(--font-size);
            line-height: 1;
            display: block;
        }

        .cell:active { transform: scale(0.95); }
        .cell:hover { background: rgba(255,255,255,0.05); }

        .cell.x span { 
            color: var(--accent-x); 
            filter: drop-shadow(0 0 10px var(--accent-x)); 
        }
        .cell.o span { 
            color: var(--accent-o); 
            filter: drop-shadow(0 0 10px var(--accent-o)); 
        }

        .cell.win {
            background: rgba(255,255,255,0.1);
            animation: win-pulse 1s infinite alternate;
            border: 1px solid rgba(255,255,255,0.3);
        }

        @keyframes win-pulse {
            from { box-shadow: 0 0 10px var(--primary); }
            to { box-shadow: 0 0 25px var(--primary); }
        }

        .cell.hint {
            border: 2px dashed #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }

        /* --- Footer Controls --- */
        .controls {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            width: 100%;
            align-items: center;
        }

        .status {
            text-align: center;
            font-size: 0.9rem;
            color: #cbd5e1;
            font-weight: 600;
            white-space: nowrap;
        }

        .action-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9rem;
            transition: transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .action-btn:active { transform: scale(0.96); }

        .btn-main {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.3);
        }

        .btn-sec {
            background: rgba(255,255,255,0.1);
            color: #94a3b8;
        }
        
        .btn-settings {
            background: transparent;
            color: #64748b;
            padding: 10px;
        }

        .locked { pointer-events: none; opacity: 0.8; }

    </style>
</head>
<body>

<div class="container">
    <h1>NEON TACTICS</h1>

    <div class="settings-panel" id="settings">
        <div class="row">
            <span class="row-label">–ü–æ–ª–µ</span>
            <div class="toggle-group" id="opt-size">
                <button class="t-btn active" data-v="3">3x3</button>
                <button class="t-btn" data-v="4">4x4</button>
                <button class="t-btn" data-v="5">5x5</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–ü–æ–±–µ–¥–∞</span>
            <div class="toggle-group" id="opt-win">
                <button class="t-btn active" data-v="3">3</button>
                <button class="t-btn" data-v="4">4</button>
                <button class="t-btn" data-v="5">5</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–ë–æ—Ç</span>
            <div class="toggle-group" id="opt-diff">
                <button class="t-btn" data-v="easy">–ò–∑–∏</button>
                <button class="t-btn" data-v="medium">–ù–æ—Ä–º</button>
                <button class="t-btn active" data-v="hard">–ë–û–ì</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–ò–≥—Ä–æ–∫</span>
            <div class="toggle-group" id="opt-side">
                <button class="t-btn active" data-v="X">–ó–∞ X</button>
                <button class="t-btn" data-v="O">–ó–∞ O</button>
            </div>
        </div>
        <div class="row">
            <span class="row-label">–ü–µ—Ä–≤—ã–π</span>
            <div class="toggle-group" id="opt-start">
                <button class="t-btn active" data-v="player">–Ø</button>
                <button class="t-btn" data-v="bot">–ë–æ—Ç</button>
            </div>
        </div>
    </div>

    <div class="game-wrapper">
        <div class="board" id="board"></div>
    </div>

    <div class="controls">
        <button class="action-btn btn-sec" id="btn-hint">üí°</button>
        <div class="status" id="status">–ù–∞–∂–º–∏ –°—Ç–∞—Ä—Ç</div>
        <button class="action-btn btn-main" id="btn-start">–°–¢–ê–†–¢</button>
    </div>
    
    <button class="t-btn" id="toggle-settings" style="margin-top:-10px; color:#475569; font-size:0.8rem;">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
</div>

<script>
/**
 * CORE LOGIC ENGINE
 */
const Engine = {
    board: [],
    size: 3,
    winReq: 3,
    active: false,
    turn: 'X',
    
    // –ö—ç—à –ª–∏–Ω–∏–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 4x4, 5x5)
    linesCache: [],
    cacheKey: '',

    init(size, winReq) {
        this.size = size;
        this.winReq = winReq;
        this.board = Array(size * size).fill(null);
        this.active = true;
        this.generateLines();
    },

    generateLines() {
        const key = `${this.size}-${this.winReq}`;
        if (this.cacheKey === key) return; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à

        this.linesCache = [];
        const s = this.size;
        const w = this.winReq;

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤—ã–∏–≥—Ä—ã—à–Ω—ã—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤ –¥–ª–∏–Ω–æ–π winReq
        // Rows
        for (let r = 0; r < s; r++) {
            for (let c = 0; c <= s - w; c++) {
                let line = [];
                for (let k = 0; k < w; k++) line.push(r * s + c + k);
                this.linesCache.push(line);
            }
        }
        // Cols
        for (let c = 0; c < s; c++) {
            for (let r = 0; r <= s - w; r++) {
                let line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c);
                this.linesCache.push(line);
            }
        }
        // Diagonals
        for (let r = 0; r <= s - w; r++) {
            for (let c = 0; c <= s - w; c++) {
                let line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c + k);
                this.linesCache.push(line);
            }
        }
        // Anti-Diagonals
        for (let r = 0; r <= s - w; r++) {
            for (let c = w - 1; c < s; c++) {
                let line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c - k);
                this.linesCache.push(line);
            }
        }
        this.cacheKey = key;
    },

    move(idx, sym) {
        if (!this.active || this.board[idx]) return null;
        this.board[idx] = sym;
        const winLine = this.checkWin(sym);
        
        if (winLine) {
            this.active = false;
            return { result: 'win', line: winLine };
        } else if (!this.board.includes(null)) {
            this.active = false;
            return { result: 'draw' };
        }
        
        this.turn = this.turn === 'X' ? 'O' : 'X';
        return { result: 'continue' };
    },

    checkWin(sym) {
        for (let line of this.linesCache) {
            if (line.every(i => this.board[i] === sym)) return line;
        }
        return null;
    }
};

/**
 * AI BRAIN (EVOLVED)
 */
const AI = {
    getBestMove(board, botSym, difficulty) {
        const playerSym = botSym === 'X' ? 'O' : 'X';
        const emptyIndices = board.map((v, i) => v === null ? i : null).filter(v => v !== null);

        // 1. –î–µ–±—é—Ç (–†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –¥–ª—è —É—Ä–æ–≤–Ω—è "–ë–û–ì")
        if (emptyIndices.length === board.length && difficulty === 'hard') {
            return this.getOpeningMove(Engine.size);
        }
        
        // 2. –£—Ä–æ–≤–µ–Ω—å "–ì–ª—É–ø—ã–π" (–†–∞–Ω–¥–æ–º —Å —à–∞–Ω—Å–æ–º –Ω–∞ –æ—à–∏–±–∫—É)
        if (difficulty === 'easy') {
            if (Math.random() > 0.3) return this.randomMove(emptyIndices); // 70% —Ä–∞–Ω–¥–æ–º
            // 30% –ø—ã—Ç–∞–µ—Ç—Å—è –¥—É–º–∞—Ç—å (–∏–¥–µ—Ç –≤ –ª–æ–≥–∏–∫—É –Ω–∏–∂–µ)
        }

        // 3. CRITICAL EYE: –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–≥–Ω–æ–≤–µ–Ω–Ω—ã—Ö —É–≥—Ä–æ–∑ (–§–∏–∫—Å –¥–ª—è 4—Ö4/5—Ö5)
        // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º: "–ú–æ–≥—É —è –≤—ã–∏–≥—Ä–∞—Ç—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å?"
        let winMove = this.findCriticalMove(board, botSym, emptyIndices);
        if (winMove !== -1) return winMove;

        // –ü–æ—Ç–æ–º –∏—â–µ–º: "–ú–æ–∂–µ—Ç –ª–∏ –≤—Ä–∞–≥ –≤—ã–∏–≥—Ä–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º —Ö–æ–¥–æ–º?"
        let blockMove = this.findCriticalMove(board, playerSym, emptyIndices);
        if (blockMove !== -1) {
            // –ï—Å–ª–∏ "–°—Ä–µ–¥–Ω–∏–π" —É—Ä–æ–≤–µ–Ω—å, –µ—Å—Ç—å 30% —à–∞–Ω—Å –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –±–ª–æ–∫ (–æ—à–∏–±–∫–∞)
            if (difficulty === 'medium' && Math.random() < 0.3) {
                 return this.randomMove(emptyIndices);
            }
            return blockMove;
        }

        // 4. –ï—Å–ª–∏ –Ω–µ—Ç –º–≥–Ω–æ–≤–µ–Ω–Ω—ã—Ö —É–≥—Ä–æ–∑, –∑–∞–ø—É—Å–∫–∞–µ–º Minimax (—Ç–æ–ª—å–∫–æ –¥–ª—è Hard/Medium)
        if (difficulty === 'easy') return this.randomMove(emptyIndices);
        
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≥–ª—É–±–∏–Ω—ã
        let maxDepth = (Engine.size === 3) ? 9 : (Engine.size === 4) ? 3 : 2;
        
        return this.minimax(board, 0, true, -Infinity, Infinity, botSym, playerSym, maxDepth).index;
    },

    // –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –ø–µ—Ä–≤—ã—Ö —Ö–æ–¥–æ–≤
    getOpeningMove(size) {
        const center = Math.floor((size * size) / 2);
        const corners = [0, size-1, size*(size-1), (size*size)-1];
        
        const roll = Math.random();
        // 60% –¶–µ–Ω—Ç—Ä (–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ª—É—á—à–µ)
        if (roll < 0.6) return center; 
        // 30% –£–≥–æ–ª (–æ—Å—Ç—Ä–∞—è –∏–≥—Ä–∞)
        if (roll < 0.9) return corners[Math.floor(Math.random() * corners.length)];
        // 10% –†–∞–Ω–¥–æ–º (—Ö–∞–æ—Å)
        return Math.floor(Math.random() * (size * size));
    },

    // –ü–æ–∏—Å–∫ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ö–æ–¥–∞ (–ø–æ–±–µ–¥–∞ –∏–ª–∏ –±–ª–æ–∫)
    findCriticalMove(board, sym, empties) {
        // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –≤—ã–∏–≥—Ä—ã—à–Ω—ã–º –ª–∏–Ω–∏—è–º
        // –ï—Å–ª–∏ –≤ –ª–∏–Ω–∏–∏ (WinReq - 1) —Å–∏–º–≤–æ–ª–æ–≤ == sym –∏ 1 –ø—É—Å—Ç–∞—è –∫–ª–µ—Ç–∫–∞ -> —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ö–æ–¥
        for (let line of Engine.linesCache) {
            let countSym = 0;
            let emptyIdx = -1;
            
            for (let idx of line) {
                if (board[idx] === sym) countSym++;
                else if (board[idx] === null) emptyIdx = idx;
                else { // –¢–∞–º —á—É–∂–æ–π —Å–∏–º–≤–æ–ª
                    countSym = -999; 
                    break; 
                }
            }

            if (countSym === Engine.winReq - 1 && emptyIdx !== -1) {
                return emptyIdx;
            }
        }
        return -1;
    },

    minimax(board, depth, isMax, alpha, beta, botSym, playerSym, maxDepth) {
        // –¢–µ—Ä–º–∏–Ω–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —ç–º—É–ª—è—Ü–∏–∏
        // –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –±—ã—Å—Ç—Ä—ã–π —á–µ–∫ —á–µ—Ä–µ–∑ findCriticalMove "–Ω–∞–æ–±–æ—Ä–æ—Ç" –∏–ª–∏ –±–∞–∑–æ–≤—É—é –ª–æ–≥–∏–∫—É
        // –ù–æ –∑–¥–µ—Å—å —É–ø—Ä–æ—Å—Ç–∏–º: –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥—É —á–µ—Ä–µ–∑ Engine lines
        
        // –í–ù–ò–ú–ê–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–±–µ–¥—É –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ Minimax –¥–æ—Ä–æ–≥–æ. 
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —ç–≤—Ä–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –≥–ª—É–±–∏–Ω–∞ 0, –∏–Ω–∞—á–µ —Ä–µ–∫—É—Ä—Å–∏—è
        
        // –ë–∞–∑–æ–≤—ã–µ —Å–ª—É—á–∞–∏
        // (–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≤ —Ä–µ–∞–ª—å–Ω–æ–º minimax –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–±–µ–¥—É –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Ö–æ–¥–∞.
        // –ó–¥–µ—Å—å –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ –∫–æ–¥–∞ –º—ã –æ—Ü–µ–Ω–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é)
        
        const empties = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
        if (empties.length === 0 || depth >= maxDepth) {
            return { score: this.evaluate(board, botSym, playerSym) };
        }

        if (isMax) {
            let bestScore = -Infinity;
            let bestMove = empties[0];
            
            for (let idx of empties) {
                board[idx] = botSym;
                // –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)
                if (this.checkWinFast(board, botSym)) {
                    board[idx] = null;
                    return { score: 10000 - depth, index: idx };
                }
                
                let score = this.minimax(board, depth + 1, false, alpha, beta, botSym, playerSym, maxDepth).score;
                board[idx] = null;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = idx;
                }
                alpha = Math.max(alpha, bestScore);
                if (beta <= alpha) break;
            }
            return { score: bestScore, index: bestMove };
        } else {
            let bestScore = Infinity;
            let bestMove = empties[0];
            
            for (let idx of empties) {
                board[idx] = playerSym;
                if (this.checkWinFast(board, playerSym)) {
                    board[idx] = null;
                    return { score: -10000 + depth, index: idx };
                }
                
                let score = this.minimax(board, depth + 1, true, alpha, beta, botSym, playerSym, maxDepth).score;
                board[idx] = null;
                
                if (score < bestScore) {
                    bestScore = score;
                    bestMove = idx;
                }
                beta = Math.min(beta, bestScore);
                if (beta <= alpha) break;
            }
            return { score: bestScore, index: bestMove };
        }
    },

    checkWinFast(board, sym) {
        for (let line of Engine.linesCache) {
            let win = true;
            for (let i of line) {
                if (board[i] !== sym) { win = false; break; }
            }
            if (win) return true;
        }
        return false;
    },

    evaluate(board, bot, player) {
        let score = 0;
        for (let line of Engine.linesCache) {
            let bCount = 0;
            let pCount = 0;
            for (let idx of line) {
                if (board[idx] === bot) bCount++;
                else if (board[idx] === player) pCount++;
            }
            // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: –õ–∏–Ω–∏–∏, –≥–¥–µ —Ç–æ–ª—å–∫–æ –º—ã
            if (pCount === 0 && bCount > 0) score += Math.pow(10, bCount);
            // –õ–∏–Ω–∏–∏, –≥–¥–µ —Ç–æ–ª—å–∫–æ –≤—Ä–∞–≥ (–æ–ø–∞—Å–Ω–æ!)
            if (bCount === 0 && pCount > 0) score -= Math.pow(10, pCount + 1); // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∑–∞—â–∏—Ç–µ
        }
        return score;
    },

    randomMove(indices) {
        return indices[Math.floor(Math.random() * indices.length)];
    }
};

/**
 * UI & CONTROLLER
 */
const App = {
    settings: {
        size: 3,
        win: 3,
        diff: 'hard',
        side: 'X',
        start: 'player'
    },
    
    init() {
        this.bindEvents();
        this.updateBoardLayout(); // –ü–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä
    },

    bindEvents() {
        // Toggles
        document.querySelectorAll('.t-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const group = btn.parentNode;
                group.querySelectorAll('.t-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Parse value
                const val = btn.dataset.v;
                const key = group.id.split('-')[1]; // size, win, diff...
                this.settings[key] = isNaN(val) ? val : parseInt(val);

                // Validation
                if (this.settings.win > this.settings.size) {
                    this.settings.win = this.settings.size;
                    this.syncUI();
                }
                
                // –ï—Å–ª–∏ –º–µ–Ω—è–µ–º –ø–æ–ª–µ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä—É –≤–∏–∑—É–∞–ª—å–Ω–æ
                if (key === 'size') {
                    this.updateBoardLayout();
                    this.setStatus('–ù–∞–∂–º–∏ –°–¢–ê–†–¢');
                }
            });
        });

        document.getElementById('btn-start').addEventListener('click', () => this.startGame());
        document.getElementById('btn-hint').addEventListener('click', () => this.showHint());
        
        // –°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        const setPanel = document.getElementById('settings');
        const togBtn = document.getElementById('toggle-settings');
        togBtn.addEventListener('click', () => {
            setPanel.classList.toggle('collapsed');
            togBtn.textContent = setPanel.classList.contains('collapsed') ? '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏' : 'üîº –°–∫—Ä—ã—Ç—å';
        });
    },

    syncUI() {
        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ win –µ—Å–ª–∏ size –∏–∑–º–µ–Ω–∏–ª—Å—è
        document.querySelectorAll('#opt-win .t-btn').forEach(b => {
            b.classList.remove('active');
            if (parseInt(b.dataset.v) === this.settings.win) b.classList.add('active');
            // –°–∫—Ä—ã—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            b.style.display = (parseInt(b.dataset.v) > this.settings.size) ? 'none' : 'block';
        });
    },

    updateBoardLayout() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        const size = this.settings.size;
        
        // CSS Grid Update
        document.documentElement.style.setProperty('--grid-cols', size);
        
        // Font size Calc (–ß—Ç–æ–±—ã –Ω–µ –ø—Ä—ã–≥–∞–ª–æ)
        // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è ~300-500px.
        // –î–ª—è 3x3 —à—Ä–∏—Ñ—Ç –±–æ–ª—å—à–æ–π, –¥–ª—è 5x5 –º–µ–Ω—å—à–µ.
        // –§–æ—Ä–º—É–ª–∞: (BoardWidth / Size) * 0.6
        // –ù–æ BoardWidth —Ä–µ–∑–∏–Ω–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—É—é –µ–¥–∏–Ω–∏—Ü—É.
        // 100% —à–∏—Ä–∏–Ω—ã –∫–ª–µ—Ç–∫–∏.
        const fontSize = size === 3 ? '4rem' : size === 4 ? '2.5rem' : '1.8rem';
        
        // Mobile adjustment calc happens in CSS via calc or updated here
        // –ü—Ä–æ—â–µ –∑–∞–¥–∞—Ç—å –≤ CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å—Ç–∏–ª—è
        board.style.setProperty('--font-size', fontSize);

        for (let i = 0; i < size * size; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.i = i;
            cell.innerHTML = `<span></span>`; // Span for centering logic
            cell.addEventListener('click', () => this.handleInput(i));
            board.appendChild(cell);
        }
    },

    setStatus(msg, color = '#cbd5e1') {
        const el = document.getElementById('status');
        el.textContent = msg;
        el.style.color = color;
    },

    startGame() {
        // Collapse settings on start for better view
        document.getElementById('settings').classList.add('collapsed');
        document.getElementById('toggle-settings').textContent = '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏';

        Engine.init(this.settings.size, this.settings.win);
        this.updateBoardLayout(); // Clean board
        
        const playerStarts = this.settings.start === 'player';
        // –õ–æ–≥–∏–∫–∞ —Ö–æ–¥–∞:
        // –ï—Å–ª–∏ Player –≤—ã–±—Ä–∞–ª X –∏ Start Player -> Engine Turn X (—Å–æ–≤–ø–∞–¥–∞–µ—Ç)
        // –ï—Å–ª–∏ Player –≤—ã–±—Ä–∞–ª O –∏ Start Player -> Player –∏–≥—Ä–∞–µ—Ç O. –ó–Ω–∞—á–∏—Ç Engine Turn O.
        
        // –£–ø—Ä–æ—â–µ–Ω–∏–µ: Engine.turn –≤—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –°–ò–ú–í–û–õ, –∫–æ—Ç–æ—Ä—ã–π —Å–µ–π—á–∞—Å —Ö–æ–¥–∏—Ç.
        // –ö—Ç–æ —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º?
        Engine.turn = playerStarts ? this.settings.side : (this.settings.side === 'X' ? 'O' : 'X');
        
        this.renderTurnInfo();

        if (!playerStarts) {
            this.botTurn();
        }
    },

    renderTurnInfo() {
        if (!Engine.active) return;
        const isMyTurn = Engine.turn === this.settings.side;
        if (isMyTurn) {
            this.setStatus(`–í–∞—à —Ö–æ–¥ (${this.settings.side})`, '#38bdf8');
        } else {
            this.setStatus(`–î—É–º–∞–µ—Ç –±–æ—Ç...`, '#94a3b8');
        }
    },

    handleInput(idx) {
        if (!Engine.active) return;
        // –ú–æ–π —Ö–æ–¥?
        if (Engine.turn !== this.settings.side) return;
        
        const res = Engine.move(idx, this.settings.side);
        if (!res) return; // –ó–∞–Ω—è—Ç–æ

        this.updateCell(idx, this.settings.side);
        
        if (res.result === 'continue') {
            this.botTurn();
        } else {
            this.endGame(res);
        }
    },

    updateCell(idx, sym) {
        const cell = document.getElementById('board').children[idx];
        cell.className = `cell ${sym.toLowerCase()}`;
        cell.querySelector('span').textContent = sym;
    },

    async botTurn() {
        const boardEl = document.getElementById('board');
        boardEl.classList.add('locked');
        this.renderTurnInfo();

        // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è (—á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é)
        await new Promise(r => setTimeout(r, 400));
        
        // –í—ã–Ω–æ—Å–∏–º —Ç—è–∂–µ–ª—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∏–∑ –ø–æ—Ç–æ–∫–∞ —Ä–µ–Ω–¥–µ—Ä–∞
        setTimeout(() => {
            const botSym = this.settings.side === 'X' ? 'O' : 'X';
            const idx = AI.getBestMove([...Engine.board], botSym, this.settings.diff);
            
            if (idx !== -1) {
                const res = Engine.move(idx, botSym);
                this.updateCell(idx, botSym);
                
                if (res.result !== 'continue') {
                    this.endGame(res);
                } else {
                    this.renderTurnInfo();
                }
            }
            boardEl.classList.remove('locked');
        }, 10);
    },

    endGame(res) {
        const boardEl = document.getElementById('board');
        boardEl.classList.remove('locked');
        
        if (res.result === 'draw') {
            this.setStatus('–ù–ò–ß–¨–Ø', '#fff');
        } else {
            const isWin = Engine.board[res.line[0]] === this.settings.side;
            this.setStatus(isWin ? '–ü–û–ë–ï–î–ê!' : '–ü–û–¢–†–ê–ß–ï–ù–û', isWin ? '#38bdf8' : '#f43f5e');
            
            // Highlight
            res.line.forEach(i => boardEl.children[i].classList.add('win'));
        }
        
        // Auto open settings after delay
        setTimeout(() => {
            document.getElementById('toggle-settings').style.display = 'block';
        }, 1000);
    },

    showHint() {
        if (!Engine.active || Engine.turn !== this.settings.side) return;
        
        const hintIdx = AI.getBestMove([...Engine.board], this.settings.side, 'hard');
        if (hintIdx !== -1) {
            const cell = document.getElementById('board').children[hintIdx];
            cell.classList.add('hint');
            setTimeout(() => cell.classList.remove('hint'), 1000);
        }
    }
};

// Start
App.init();

</script>
</body>
</html>
