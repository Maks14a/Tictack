<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe AI</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-bg: rgba(255, 255, 255, 0.05);
            --primary: #00b4d8;
            --accent-x: #ff6b6b;
            --accent-o: #4dffea;
            --text: #ffffff;
            --grid-size: 3; /* –ú–µ–Ω—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ JS */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        h1 {
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 180, 216, 0.4);
            text-align: center;
            font-size: 2rem;
        }

        /* --- Settings Panel --- */
        .settings-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-group h3 {
            font-size: 0.9rem;
            color: #90e0ef;
            opacity: 0.8;
        }

        .toggle-container {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
        }

        .toggle-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background: transparent;
            color: #aaa;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .toggle-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 10px rgba(0, 180, 216, 0.3);
        }

        /* --- Game Board --- */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .status-bar {
            font-size: 1.2rem;
            font-weight: bold;
            min-height: 1.5em;
            color: #caf0f8;
            text-align: center;
        }

        .board {
            display: grid;
            /* –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–µ—Ç–∫–∞ */
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            gap: 8px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1; /* –ö–≤–∞–¥—Ä–∞—Ç–Ω–æ–µ –ø–æ–ª–µ –≤—Å–µ–≥–¥–∞ */
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .cell {
            background: rgba(255,255,255,0.07);
            border-radius: 8px;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            
            /* –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ */
            font-size: calc(300px / var(--grid-size)); 
            font-weight: 900;
        }

        /* –ê–¥–∞–ø—Ç–∏–≤ —à—Ä–∏—Ñ—Ç–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
        @media (max-width: 500px) {
            .cell {
                font-size: calc(80vw / var(--grid-size) - 10px);
            }
        }

        .cell:hover {
            background: rgba(255,255,255,0.12);
        }

        .cell.x { color: var(--accent-x); text-shadow: 0 0 15px rgba(255, 107, 107, 0.5); }
        .cell.o { color: var(--accent-o); text-shadow: 0 0 15px rgba(77, 255, 234, 0.5); }
        
        .cell.winner {
            background: rgba(0, 255, 136, 0.15);
            border-color: #00ff88;
            transform: scale(0.95);
        }

        /* –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏ */
        .cell.hint-highlight {
            animation: pulse-hint 1.5s infinite;
            border: 2px dashed rgba(255, 255, 0, 0.5);
        }

        @keyframes pulse-hint {
            0% { background: rgba(255, 255, 0, 0.05); }
            50% { background: rgba(255, 255, 0, 0.15); }
            100% { background: rgba(255, 255, 0, 0.05); }
        }

        /* --- Controls --- */
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.1s, filter 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:active { transform: translateY(2px); }

        .btn-primary {
            background: var(--primary);
            color: #fff;
            box-shadow: 0 4px 15px rgba(0, 180, 216, 0.4);
        }

        .btn-secondary {
            background: #495057;
            color: #fff;
        }

        .btn-hint {
            background: #ffd166;
            color: #333;
        }

        /* –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∫–ª–∏–∫–æ–≤ –∫–æ–≥–¥–∞ –¥—É–º–∞–µ—Ç –±–æ—Ç */
        .board.locked {
            pointer-events: none;
            opacity: 0.9;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>‚öîÔ∏è –£–º–Ω—ã–µ –ö—Ä–µ—Å—Ç–∏–∫–∏-–ù–æ–ª–∏–∫–∏ 2.0</h1>

    <div class="settings-panel">
        <div class="setting-group">
            <h3>–†–∞–∑–º–µ—Ä –ø–æ–ª—è</h3>
            <div class="toggle-container" id="size-select">
                <button class="toggle-btn active" data-val="3">3x3</button>
                <button class="toggle-btn" data-val="4">4x4</button>
                <button class="toggle-btn" data-val="5">5x5</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>–ü–æ–±–µ–¥–∞ (–≤ —Ä—è–¥)</h3>
            <div class="toggle-container" id="win-select">
                <button class="toggle-btn active" data-val="3">3</button>
                <button class="toggle-btn" data-val="4">4</button>
                <button class="toggle-btn" data-val="5">5</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>–°–ª–æ–∂–Ω–æ—Å—Ç—å</h3>
            <div class="toggle-container" id="diff-select">
                <button class="toggle-btn" data-val="easy">–õ–µ–≥–∫–æ</button>
                <button class="toggle-btn" data-val="medium">–°—Ä–µ–¥–Ω–µ</button>
                <button class="toggle-btn active" data-val="hard">–•–∞—Ä–¥</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>–í—ã –∏–≥—Ä–∞–µ—Ç–µ –∑–∞</h3>
            <div class="toggle-container" id="symbol-select">
                <button class="toggle-btn active" data-val="X">X (–ö—Ä–µ—Å—Ç–∏–∫)</button>
                <button class="toggle-btn" data-val="O">O (–ù–æ–ª–∏–∫)</button>
            </div>
        </div>

        <div class="setting-group">
            <h3>–ü–µ—Ä–≤—ã–π —Ö–æ–¥</h3>
            <div class="toggle-container" id="starter-select">
                <button class="toggle-btn active" data-val="player">–ò–≥—Ä–æ–∫</button>
                <button class="toggle-btn" data-val="bot">–ë–æ—Ç</button>
            </div>
        </div>
    </div>

    <div class="game-area">
        <div class="status-bar" id="status">–ù–∞–∂–º–∏—Ç–µ "–°—Ç–∞—Ä—Ç" –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã</div>
        <div class="board" id="board">
            </div>
        
        <div class="controls">
            <button class="btn btn-primary" id="btn-new-game">üéÆ –°—Ç–∞—Ä—Ç / –†–µ—Å—Ç–∞—Ä—Ç</button>
            <button class="btn btn-hint" id="btn-hint">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        </div>
    </div>
</div>

<script>
/**
 * –Ø–¥—Ä–æ –∏–≥—Ä—ã: –õ–æ–≥–∏–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–±–µ–¥—ã
 */
class GameEngine {
    constructor() {
        this.board = [];
        this.size = 3;
        this.winLength = 3;
        this.currentPlayer = 'X'; // –í—Å–µ–≥–¥–∞ X –∏–ª–∏ O
        this.isActive = false;
        this.winner = null; // 'X', 'O', 'draw' –∏–ª–∏ null
        this.winningLine = [];
    }

    init(size, winLength) {
        this.size = size;
        this.winLength = winLength;
        this.board = Array(size * size).fill(null);
        this.currentPlayer = 'X'; // –ü–æ –ø—Ä–∞–≤–∏–ª–∞–º –∫—Ä–µ—Å—Ç–∏–∫–∏ —Ö–æ–¥—è—Ç –ø–µ—Ä–≤—ã–º–∏, –Ω–æ –º—ã –º–æ–∂–µ–º –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å —Ö–æ–¥
        this.isActive = true;
        this.winner = null;
        this.winningLine = [];
    }

    makeMove(index, symbol) {
        if (!this.isActive || this.board[index] !== null) return false;
        this.board[index] = symbol;
        
        if (this.checkWin(index, symbol)) {
            this.isActive = false;
            this.winner = symbol;
        } else if (this.board.every(cell => cell !== null)) {
            this.isActive = false;
            this.winner = 'draw';
        } else {
            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
        }
        return true;
    }

    checkWin(lastIndex, symbol) {
        // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã –≤–æ–∫—Ä—É–≥ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ö–æ–¥–∞
        // –ù–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ AI –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –≤—Å–µ–≥–æ –ø–æ–ª—è
        const lines = this.getAllLines();
        for (let line of lines) {
            if (line.every(idx => this.board[idx] === symbol)) {
                this.winningLine = line;
                return true;
            }
        }
        return false;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤—ã–∏–≥—Ä—ã—à–Ω—ã—Ö –ª–∏–Ω–∏–π (–∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏)
    getAllLines() {
        const lines = [];
        const s = this.size;
        const w = this.winLength;

        // Horizontal
        for (let r = 0; r < s; r++) {
            for (let c = 0; c <= s - w; c++) {
                const line = [];
                for (let k = 0; k < w; k++) line.push(r * s + c + k);
                lines.push(line);
            }
        }
        // Vertical
        for (let c = 0; c < s; c++) {
            for (let r = 0; r <= s - w; r++) {
                const line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c);
                lines.push(line);
            }
        }
        // Diagonal
        for (let r = 0; r <= s - w; r++) {
            for (let c = 0; c <= s - w; c++) {
                const line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c + k);
                lines.push(line);
            }
        }
        // Anti-Diagonal
        for (let r = 0; r <= s - w; r++) {
            for (let c = w - 1; c < s; c++) {
                const line = [];
                for (let k = 0; k < w; k++) line.push((r + k) * s + c - k);
                lines.push(line);
            }
        }
        return lines;
    }

    getEmptyCells() {
        return this.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
    }
    
    // –ö–ª–æ–Ω —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è AI —Å–∏–º—É–ª—è—Ü–∏–∏
    clone() {
        const newGame = new GameEngine();
        newGame.size = this.size;
        newGame.winLength = this.winLength;
        newGame.board = [...this.board];
        newGame.currentPlayer = this.currentPlayer;
        newGame.isActive = this.isActive;
        return newGame;
    }
}

/**
 * –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç
 */
class AI {
    constructor(game) {
        this.game = game;
        this.maxDepth = 100; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    }

    getBestMove(difficulty, botSymbol) {
        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≥–ª—É–±–∏–Ω—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–ª—è
        if (this.game.size === 3) this.maxDepth = 9;
        else if (this.game.size === 4) this.maxDepth = 4; // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è 4x4
        else this.maxDepth = 3; // –°–∏–ª—å–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è 5x5

        if (difficulty === 'easy') return this.getRandomMove();
        if (difficulty === 'medium') {
            // 30% –æ—à–∏–±–∫–∞, –∏–Ω–∞—á–µ Minimax —Å –º–∞–ª–æ–π –≥–ª—É–±–∏–Ω–æ–π
            if (Math.random() < 0.3) return this.getRandomMove();
            this.maxDepth = 2; 
            return this.minimaxRoot(botSymbol);
        }
        if (difficulty === 'hard') {
            return this.minimaxRoot(botSymbol);
        }
    }

    getRandomMove() {
        const empties = this.game.getEmptyCells();
        if (empties.length === 0) return -1;
        return empties[Math.floor(Math.random() * empties.length)];
    }

    // –û—Ü–µ–Ω–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ (–∫–æ–≥–¥–∞ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –≥–ª—É–±–∏–Ω—ã)
    evaluate(board, playerSymbol, opponentSymbol) {
        let score = 0;
        const lines = this.game.getAllLines();
        
        for (let line of lines) {
            let pCount = 0;
            let oCount = 0;
            for (let idx of line) {
                if (board[idx] === playerSymbol) pCount++;
                else if (board[idx] === opponentSymbol) oCount++;
            }

            // –ï—Å–ª–∏ –ª–∏–Ω–∏—è —á–∏—Å—Ç–∞—è (–Ω–µ—Ç –≤—Ä–∞–≥–æ–≤), —ç—Ç–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª
            if (oCount === 0 && pCount > 0) score += Math.pow(10, pCount);
            // –ï—Å–ª–∏ —É –≤—Ä–∞–≥–∞ –ª–∏–Ω–∏—è –ø–æ—á—Ç–∏ —Å–æ–±—Ä–∞–Ω–∞ - —ç—Ç–æ –æ—á–µ–Ω—å –ø–ª–æ—Ö–æ
            if (pCount === 0 && oCount > 0) score -= Math.pow(10, oCount + 1); // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∑–∞—â–∏—Ç–µ
        }
        return score;
    }

    minimaxRoot(playerSymbol) {
        const empties = this.game.getEmptyCells();
        // –ü–µ—Ä–≤—ã–π —Ö–æ–¥ –≤ —Ü–µ–Ω—Ç—Ä –∏–ª–∏ —É–≥–æ–ª –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        if (empties.length === this.game.board.length) {
             const center = Math.floor(this.game.board.length / 2);
             return center;
        }

        let bestScore = -Infinity;
        let bestMove = -1;
        const opponent = playerSymbol === 'X' ? 'O' : 'X';

        for (let move of empties) {
            this.game.board[move] = playerSymbol;
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω—É—é –ø–æ–±–µ–¥—É
            if (this.game.checkWin(move, playerSymbol)) {
                this.game.board[move] = null;
                return move;
            }

            let score = this.minimax(this.game.board, 0, false, -Infinity, Infinity, playerSymbol, opponent);
            this.game.board[move] = null; // Backtrack

            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }
        return bestMove;
    }

    minimax(board, depth, isMaximizing, alpha, beta, player, opponent) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª—å–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π (–ø–æ–±–µ–¥–∞/–ø–æ—Ä–∞–∂–µ–Ω–∏–µ) –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ö–æ–¥–µ
        // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä–∫–∞ checkWin –∑–¥–µ—Å—å –¥–æ—Ä–æ–≥–∞—è, –ø–æ—ç—Ç–æ–º—É –º—ã –ø—Ä–æ–≤–µ—Ä—è–µ–º "—Å–ª—É—á–∏–ª–∞—Å—å –ª–∏ –ø–æ–±–µ–¥–∞" –¥–æ –≤—Ö–æ–¥–∞
        // –ù–æ –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –∫–æ–¥–∞ –æ—Å—Ç–∞–≤–∏–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ç—É—Ç, –Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º
        
        // –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è, –ø—Ä–æ–≤–µ—Ä–∏–º —Å—Ç–∞—Ç—É—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Ö–æ–¥–∞ (—ç–º—É–ª—è—Ü–∏—è)
        // –í —Ä–µ–∞–ª—å–Ω–æ–º Minimax –ª—É—á—à–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å lastMove, –Ω–æ –∑–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ–º —ç–≤—Ä–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –≥–ª—É–±–∏–Ω–∞ > 0
        
        // –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–∏ - –ª–∏–º–∏—Ç –≥–ª—É–±–∏–Ω—ã
        if (depth >= this.maxDepth) {
            return this.evaluate(board, player, opponent);
        }

        const empties = [];
        for(let i=0; i<board.length; i++) if(board[i]===null) empties.push(i);

        if (empties.length === 0) return 0; // –ù–∏—á—å—è

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (let move of empties) {
                board[move] = player;
                // Check win immediately
                let evalScore;
                if (this.isWin(board, player)) {
                    evalScore = 10000 - depth;
                } else {
                    evalScore = this.minimax(board, depth + 1, false, alpha, beta, player, opponent);
                }
                board[move] = null;
                
                maxEval = Math.max(maxEval, evalScore);
                alpha = Math.max(alpha, evalScore);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let move of empties) {
                board[move] = opponent;
                // Check win immediately
                let evalScore;
                if (this.isWin(board, opponent)) {
                    evalScore = -10000 + depth;
                } else {
                    evalScore = this.minimax(board, depth + 1, true, alpha, beta, player, opponent);
                }
                board[move] = null;

                minEval = Math.min(minEval, evalScore);
                beta = Math.min(beta, evalScore);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã –¥–ª—è Minimax (—Ä–∞–±–æ—Ç–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ —á–µ–º –∫–ª–∞—Å—Å–æ–≤–∞—è)
    isWin(board, sym) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏ –∏–∑ GameEngine
        const lines = this.game.getAllLines();
        for (let line of lines) {
            let count = 0;
            for (let idx of line) {
                if (board[idx] === sym) count++;
                else break; 
            }
            if (count === this.game.winLength) return true;
        }
        return false;
    }
}

/**
 * UI –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä
 */
const UI = {
    settings: {
        size: 3,
        win: 3,
        difficulty: 'hard',
        userSymbol: 'X',
        starter: 'player'
    },
    game: new GameEngine(),
    ai: null,
    boardEl: document.getElementById('board'),
    statusEl: document.getElementById('status'),
    isBotTurn: false,

    init() {
        this.setupToggles();
        document.getElementById('btn-new-game').addEventListener('click', () => this.startGame());
        document.getElementById('btn-hint').addEventListener('click', () => this.showHint());
        this.ai = new AI(this.game);
        
        // Auto start
        this.renderBoard(); 
    },

    setupToggles() {
        document.querySelectorAll('.toggle-container').forEach(container => {
            container.addEventListener('click', (e) => {
                if (e.target.classList.contains('toggle-btn')) {
                    // Remove active from siblings
                    container.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update setting
                    const type = container.id.split('-')[0]; // size, win, diff...
                    let val = e.target.dataset.val;
                    if (!isNaN(val)) val = parseInt(val);
                    
                    this.settings[type] = val;

                    // –í–∞–ª–∏–¥–∞—Ü–∏—è: —É—Å–ª–æ–≤–∏–µ –ø–æ–±–µ–¥—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–ª—è
                    if (type === 'size') {
                         this.validateWinCondition();
                    }
                    if (type === 'size' || type === 'win') {
                        // –í–∏–∑—É–∞–ª—å–Ω–æ —Å–±—Ä–æ—Å–∏—Ç—å –∏–≥—Ä—É, –µ—Å–ª–∏ –º–µ–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–ª—è
                        this.game.isActive = false;
                        this.statusEl.textContent = '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑–º–µ–Ω–µ–Ω—ã. –ù–∞–∂–º–∏—Ç–µ –°—Ç–∞—Ä—Ç.';
                    }
                }
            });
        });
    },

    validateWinCondition() {
        const winContainer = document.getElementById('win-select');
        const btns = winContainer.querySelectorAll('.toggle-btn');
        let maxAvailable = 3;

        btns.forEach(btn => {
            const val = parseInt(btn.dataset.val);
            if (val > this.settings.size) {
                btn.style.display = 'none';
                if (btn.classList.contains('active')) {
                    btn.classList.remove('active');
                }
            } else {
                btn.style.display = 'block';
                maxAvailable = val;
            }
        });

        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä —Å–∫—Ä—ã—Ç, –≤—ã–±—Ä–∞—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π
        if (this.settings.win > this.settings.size) {
             this.settings.win = this.settings.size;
             // –í–∏–∑—É–∞–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
             btns.forEach(b => {
                 if(parseInt(b.dataset.val) === this.settings.size) b.classList.add('active');
             });
        }
    },

    startGame() {
        this.game.init(this.settings.size, this.settings.win);
        this.ai = new AI(this.game);
        this.isBotTurn = false;
        
        // CSS Grid Update
        document.documentElement.style.setProperty('--grid-size', this.settings.size);
        
        this.renderBoard();
        this.updateStatus(`–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –í—ã –∑–∞ ${this.settings.userSymbol}`);

        // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞
        // –ü–æ –ø—Ä–∞–≤–∏–ª–∞–º: X —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.
        // –ï—Å–ª–∏ User = X –∏ Starter = Player -> User —Ö–æ–¥–∏—Ç.
        // –ï—Å–ª–∏ User = O –∏ Starter = Player -> User (O) –∂–¥–µ—Ç, –ø–æ–∫–∞ X (Bot) —Å—Ö–æ–¥–∏—Ç? 
        // –û–±—ã—á–Ω–æ –≤ –∏–≥—Ä–∞—Ö "Starter = Player" –∑–Ω–∞—á–∏—Ç Player –¥–µ–ª–∞–µ—Ç –ø–µ—Ä–≤—ã–π –º—É–≤ —Å–≤–æ–∏–º —Å–∏–º–≤–æ–ª–æ–º.
        // –°–¥–µ–ª–∞–µ–º —Ç–∞–∫: –¢–æ—Ç, –∫—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç, –ø–æ–ª—É—á–∞–µ—Ç —Å–∏–º–≤–æ–ª X? –ù–µ—Ç, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª —Å–∏–º–≤–æ–ª.
        // –î–∞–≤–∞–π—Ç–µ —Ç–∞–∫: –ö—Ä–µ—Å—Ç–∏–∫–∏ –≤—Å–µ–≥–¥–∞ —Ö–æ–¥—è—Ç –ø–µ—Ä–≤—ã–º–∏. 
        // –ï—Å–ª–∏ User –≤—ã–±—Ä–∞–ª O, –∑–Ω–∞—á–∏—Ç –ë–æ—Ç (X) —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º, –¥–∞–∂–µ –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–æ "Player starts"?
        // –ß—Ç–æ–±—ã –Ω–µ –ø—É—Ç–∞—Ç—å: "–ü–µ—Ä–≤—ã–π —Ö–æ–¥" –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —á–µ–π —Å–µ–π—á–∞—Å —Ö–æ–¥. –°–∏–º–≤–æ–ª –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É.
        
        let currentMoverIsUser = (this.settings.starter === 'player');
        
        // –ù–∞—Å–∏–ª—å–Ω–æ —Å—Ç–∞–≤–∏–º current player –≤ –¥–≤–∏–∂–∫–µ –Ω–∞ —Ç–æ–≥–æ, –∫—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç
        // –ù–æ —Å–∏–º–≤–æ–ª—ã X/O –≤–∞–∂–Ω—ã –¥–ª—è –ª–æ–≥–∏–∫–∏ –ø–æ–±–µ–¥—ã.
        // –ü—É—Å—Ç—å X –≤—Å–µ–≥–¥–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç. 
        // –°—Ü–µ–Ω–∞—Ä–∏–π 1: User X, Player Start -> User moves (X). OK.
        // –°—Ü–µ–Ω–∞—Ä–∏–π 2: User O, Bot Start -> Bot moves (X). OK.
        // –°—Ü–µ–Ω–∞—Ä–∏–π 3: User X, Bot Start -> Bot moves (O)? –ù–µ—Ç, –∫—Ä–µ—Å—Ç–∏–∫–∏ –ø–µ—Ä–≤—ã–µ.
        
        // –ü—Ä–æ—â–µ: –ö—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç, —Ç–æ—Ç –∏–≥—Ä–∞–µ—Ç –ö—Ä–µ—Å—Ç–∏–∫–∞–º–∏ (X).
        // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª "–ò–≥—Ä–∞—Ç—å –∑–∞ O", —Ç–æ –æ–Ω –∏–≥—Ä–∞–µ—Ç –ù–æ–ª–∏–∫–∞–º–∏, –∑–Ω–∞—á–∏—Ç –ë–æ—Ç –∏–≥—Ä–∞–µ—Ç –ö—Ä–µ—Å—Ç–∏–∫–∞–º–∏ –∏ —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.
        
        // –ù–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å –∏ —Ç–æ, –∏ —Ç–æ.
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è: X –≤—Å–µ–≥–¥–∞ —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.
        // –ï—Å–ª–∏ User –≤–∑—è–ª X:
        //    - Starter Player: —Ö–æ–¥ User.
        //    - Starter Bot: –ë–æ—Ç –¥–µ–ª–∞–µ—Ç —Ö–æ–¥ (–∫–∞–∫ X).
        // –ï—Å–ª–∏ User –≤–∑—è–ª O:
        //    - Starter Player: –ù–ï–í–û–ó–ú–û–ñ–ù–û –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º TicTacToe (X first). 
        //    - –ù–û –º—ã —Å–¥–µ–ª–∞–µ–º –≥–∏–±–∫–æ: –¢–æ—Ç, –∫—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç, —Å—Ç–∞–≤–∏—Ç –°–í–û–ô —Å–∏–º–≤–æ–ª –ø–µ—Ä–≤—ã–º.
        
        this.game.currentPlayer = (this.settings.starter === 'player') ? this.settings.userSymbol : (this.settings.userSymbol === 'X' ? 'O' : 'X');
        
        if (this.settings.starter === 'bot') {
            this.makeBotMove();
        }
    },

    renderBoard() {
        this.boardEl.innerHTML = '';
        this.boardEl.classList.remove('locked');
        
        this.game.board.forEach((cell, index) => {
            const el = document.createElement('div');
            el.className = 'cell';
            if (cell) {
                el.classList.add(cell.toLowerCase());
                el.textContent = cell;
            }
            el.dataset.index = index;
            el.onclick = () => this.handleCellClick(index);
            this.boardEl.appendChild(el);
        });
    },

    handleCellClick(index) {
        if (this.isBotTurn || !this.game.isActive) return;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞: —Å–µ–π—á–∞—Å —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞?
        if (this.game.currentPlayer !== this.settings.userSymbol) return;

        if (this.game.makeMove(index, this.settings.userSymbol)) {
            this.updateCell(index);
            this.checkGameState();
            
            if (this.game.isActive) {
                this.makeBotMove();
            }
        }
    },

    async makeBotMove() {
        this.isBotTurn = true;
        this.boardEl.classList.add('locked');
        this.statusEl.textContent = '–ë–æ—Ç –¥—É–º–∞–µ—Ç...';
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞
        await new Promise(r => setTimeout(r, 600));

        const botSymbol = this.settings.userSymbol === 'X' ? 'O' : 'X';
        
        // –ß—Ç–æ–±—ã UI –Ω–µ –≤–∏—Å –Ω–∞ 5x5 Hard, –∏—Å–ø–æ–ª—å–∑—É–µ–º setTimeout
        setTimeout(() => {
            const move = this.ai.getBestMove(this.settings.difficulty, botSymbol);
            
            if (move !== -1) {
                this.game.makeMove(move, botSymbol);
                this.updateCell(move);
                this.checkGameState();
            }
            
            if (this.game.isActive) {
                this.isBotTurn = false;
                this.boardEl.classList.remove('locked');
                this.statusEl.textContent = `–í–∞—à —Ö–æ–¥ (${this.settings.userSymbol})`;
            }
        }, 10);
    },

    updateCell(index) {
        const cell = this.boardEl.children[index];
        const val = this.game.board[index];
        if (val) {
            cell.classList.add(val.toLowerCase());
            cell.textContent = val;
        }
    },

    checkGameState() {
        if (!this.game.isActive) {
            this.isBotTurn = false;
            this.boardEl.classList.remove('locked');
            
            if (this.game.winner === 'draw') {
                this.statusEl.textContent = '–ù–∏—á—å—è! ü§ù';
                this.statusEl.style.color = '#fff';
            } else {
                const winner = this.game.winner;
                const isUserWin = winner === this.settings.userSymbol;
                this.statusEl.textContent = isUserWin ? '–í—ã –ø–æ–±–µ–¥–∏–ª–∏! üéâ' : '–ë–æ—Ç –ø–æ–±–µ–¥–∏–ª ü§ñ';
                this.statusEl.style.color = isUserWin ? '#00ff88' : '#ff6b6b';
                
                // Highlight winning line
                this.game.winningLine.forEach(idx => {
                    this.boardEl.children[idx].classList.add('winner');
                });
            }
        }
    },

    showHint() {
        if (!this.game.isActive || this.isBotTurn) return;
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –ø–æ–¥—Å–∫–∞–∑–∫—É
        document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));

        this.statusEl.textContent = '–í—ã—á–∏—Å–ª—è—é –ª—É—á—à–∏–π —Ö–æ–¥...';
        
        setTimeout(() => {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º AI –Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ Hard –¥–ª—è –∏–≥—Ä–æ–∫–∞
            const hintMove = this.ai.getBestMove('hard', this.settings.userSymbol);
            
            if (hintMove !== -1) {
                const cell = this.boardEl.children[hintMove];
                cell.classList.add('hint-highlight');
                this.statusEl.textContent = '–ü–æ–¥—Å–∫–∞–∑–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞!';
                
                setTimeout(() => {
                   cell.classList.remove('hint-highlight');
                }, 2000);
            }
        }, 50);
    }
};

// Start
UI.init();

</script>
</body>
</html>
