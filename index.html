<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON TACTICS: ULTIMATE EDITION</title>
    <style>
        :root {
            --bg: #020617;
            --panel: rgba(30, 41, 59, 0.95);
            --primary: #38bdf8;
            --accent-x: #fb7185;
            --accent-o: #34d399;
            --text: #f1f5f9;
        }

        * { 
            box-sizing: border-box; margin: 0; padding: 0; 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        body {
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow-x: hidden;
        }

        .wrapper {
            width: 100%;
            max-width: 420px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .header-box {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            letter-spacing: 4px;
            font-size: 1.8rem;
            text-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            font-weight: 900;
        }

        .edit-tool {
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.6;
            transition: 0.3s;
        }
        .edit-tool:hover { opacity: 1; transform: scale(1.1); }

        .status-bar {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--primary);
            text-transform: uppercase;
            border: 1px solid rgba(255,255,255,0.1);
            min-height: 45px;
        }

        .settings-container {
            background: var(--panel);
            border-radius: 20px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .settings-container.hidden { display: none; }
        .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
        .row-label { font-size: 0.7rem; color: #94a3b8; font-weight: 900; text-transform: uppercase; width: 75px; }
        .group { display: flex; flex: 1; background: rgba(0,0,0,0.3); padding: 4px; border-radius: 10px; }
        .opt-btn {
            flex: 1; padding: 10px 0; border: none; background: transparent;
            color: #64748b; font-weight: bold; cursor: pointer; border-radius: 7px;
            font-size: 0.8rem; transition: 0.2s;
        }
        .opt-btn.active { background: var(--primary); color: #020617; }
        .opt-btn:disabled { opacity: 0.1; cursor: not-allowed; }

        .board-frame {
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex; align-items: center; justify-content: center;
        }

        .board-grid {
            display: grid;
            width: 100%;
            height: 100%;
            gap: 6px;
            grid-template-columns: repeat(var(--cols, 3), 1fr);
            grid-template-rows: repeat(var(--cols, 3), 1fr);
        }

        .cell {
            background: #0f172a;
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; aspect-ratio: 1 / 1;
            border: 1px solid rgba(255,255,255,0.05);
            transition: 0.15s;
        }

        .cell:active { transform: scale(0.92); }
        .cell span { font-size: var(--fs, 3rem); font-weight: 900; }
        .cell.x span { color: var(--accent-x); text-shadow: 0 0 15px var(--accent-x); }
        .cell.o span { color: var(--accent-o); text-shadow: 0 0 15px var(--accent-o); }
        .cell.winner { background: var(--primary); box-shadow: 0 0 20px var(--primary); }
        .cell.winner span { color: #020617; text-shadow: none; }
        .cell.hint { background: rgba(251, 191, 36, 0.2); border: 2px solid #fbbf24; }

        .footer-btns { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .btn {
            padding: 15px 5px; border: none; border-radius: 14px;
            font-weight: 900; cursor: pointer; text-transform: uppercase;
            font-size: 0.7rem; transition: 0.2s;
        }
        .btn-play { background: var(--primary); color: #020617; }
        .btn-side { background: #334155; color: white; }
        .btn-hint { background: #475569; color: #fbbf24; }
        .btn-undo { background: #1e293b; color: #94a3b8; border: 1px solid rgba(255,255,255,0.1); }
        .locked { pointer-events: none; }
    </style>
</head>
<body>

<div class="wrapper">
    <div class="header-box">
        <h1>NEON TACTICS</h1>
        <div class="edit-tool" onclick="customSettings()">‚úèÔ∏è</div>
    </div>

    <div class="status-bar" id="status">–ì–û–¢–û–í –ö –¢–†–£–î–£</div>

    <div class="settings-container" id="menu">
        <div class="row"><span class="row-label">–ü–û–õ–ï</span><div class="group" id="set-size"><button class="opt-btn active" onclick="config('size', 3, this)">3x3</button><button class="opt-btn" onclick="config('size', 4, this)">4x4</button><button class="opt-btn" onclick="config('size', 5, this)">5x5</button></div></div>
        <div class="row"><span class="row-label">–£–°–õ–û–í–ò–ï</span><div class="group" id="set-win"><button class="opt-btn active" data-v="3" onclick="config('win', 3, this)">3</button><button class="opt-btn" data-v="4" onclick="config('win', 4, this)">4</button><button class="opt-btn" data-v="5" onclick="config('win', 5, this)">5</button></div></div>
        <div class="row"><span class="row-label">–ú–û–ó–ì–ò</span><div class="group" id="set-diff"><button class="opt-btn" onclick="config('diff', 'easy', this)">–ò–ó–ò</button><button class="opt-btn" onclick="config('diff', 'norm', this)">–ù–û–†–ú</button><button class="opt-btn active" onclick="config('diff', 'god', this)">–ë–û–ì</button></div></div>
        <div class="row"><span class="row-label">–†–ï–ñ–ò–ú</span><div class="group" id="set-pro"><button class="opt-btn active" onclick="config('pro', false, this)">–í–´–ö–õ</button><button class="opt-btn" onclick="config('pro', true, this)">PRO</button></div></div>
        <div class="row"><span class="row-label">–Ø –ó–ê</span><div class="group" id="set-side"><button class="opt-btn active" onclick="config('playerSide', 'X', this)">X</button><button class="opt-btn" onclick="config('playerSide', 'O', this)">O</button></div></div>
        <div class="row"><span class="row-label">–•–û–î–ò–¢</span><div class="group" id="set-start"><button class="opt-btn active" onclick="config('start', 'p', this)">–Ø</button><button class="opt-btn" onclick="config('start', 'b', this)">–ë–û–¢</button></div></div>
    </div>

    <div class="board-frame"><div class="board-grid" id="board"></div></div>

    <div class="footer-btns">
        <button class="btn btn-side" onclick="toggleMenu()">‚öôÔ∏è</button>
        <button class="btn btn-hint" onclick="getHint()">üí°</button>
        <button class="btn btn-undo" onclick="undoMove()">‚Ü©Ô∏è</button>
        <button class="btn btn-play" onclick="initGame()">–ò–ì–†–ê–¢–¨</button>
    </div>
</div>

<script>
    let settings = { size: 3, win: 3, diff: 'god', pro: false, playerSide: 'X', start: 'p' };
    let session = { board: [], active: false, turn: 'X', botSide: 'O', winLines: [], history: [], tactic: 'random' };
    let botTimer;

    function customSettings() {
        let n = prompt("–†–∞–∑–º–µ—Ä –ø–æ–ª—è (N):", settings.size); if(!n) return;
        let w = prompt("–£—Å–ª–æ–≤–∏–µ –ø–æ–±–µ–¥—ã:", settings.win); if(!w) return;
        settings.size = parseInt(n); settings.win = parseInt(w);
        drawEmpty(); setStatus(`–†–ï–ñ–ò–ú: ${n}x${n} (${w})`);
    }

    function config(key, val, el) {
        settings[key] = val;
        [...el.parentElement.children].forEach(b => b.classList.remove('active'));
        el.classList.add('active');
        if (key === 'size') drawEmpty();
    }

    function toggleMenu() { document.getElementById('menu').classList.toggle('hidden'); }

    function drawEmpty() {
        const b = document.getElementById('board'); b.innerHTML = '';
        b.style.setProperty('--cols', settings.size);
        let fs = settings.size > 8 ? 1 : settings.size > 5 ? 1.5 : settings.size > 3 ? 2.5 : 3.5;
        b.style.setProperty('--fs', fs + 'rem');
        for(let i=0; i<settings.size*settings.size; i++) {
            const c = document.createElement('div'); c.className = 'cell';
            c.innerHTML = '<span></span>'; b.appendChild(c);
        }
    }

    function initGame() {
        clearTimeout(botTimer);
        session.active = true; session.history = [];
        session.board = Array(settings.size * settings.size).fill(null);
        session.botSide = settings.playerSide === 'X' ? 'O' : 'X';
        session.turn = settings.start === 'p' ? settings.playerSide : session.botSide;
        session.winLines = generateLines(settings.size, settings.win);
        // –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–π —Ç–∞–∫—Ç–∏–∫–∏ –Ω–∞ –∏–≥—Ä—É
        const tactics = ['center', 'corners', 'random'];
        session.tactic = tactics[Math.floor(Math.random() * tactics.length)];
        
        document.getElementById('menu').classList.add('hidden');
        render(); checkTurn();
    }

    function undoMove() {
        clearTimeout(botTimer);
        if (session.history.length === 0) return;
        const lastIdx = session.history[session.history.length - 1];
        let count = (session.board[lastIdx] === session.botSide) ? 2 : 1;
        for(let i = 0; i < count; i++) {
            if (session.history.length > 0) {
                let idx = session.history.pop();
                session.board[idx] = null;
            }
        }
        session.active = true;
        const xC = session.board.filter(s => s === 'X').length;
        const oC = session.board.filter(s => s === 'O').length;
        session.turn = (xC === oC) ? 'X' : 'O';
        render(); checkTurn();
    }

    function checkTurn() {
        if (!session.active) return;
        if (session.turn === session.botSide) {
            setStatus(`–ë–û–¢ (${session.tactic}) –î–£–ú–ê–ï–¢...`);
            document.getElementById('board').classList.add('locked');
            botTimer = setTimeout(botMove, 600);
        } else {
            setStatus("–¢–í–û–ô –•–û–î (" + session.turn + ")");
            document.getElementById('board').classList.remove('locked');
        }
    }

    function render() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        session.board.forEach((val, i) => {
            const c = document.createElement('div');
            c.className = 'cell' + (val ? ' ' + val.toLowerCase() : '');
            c.innerHTML = `<span>${val || ''}</span>`;
            c.onclick = () => { if(session.active && !session.board[i]) doMove(i, session.turn); };
            b.appendChild(c);
        });
    }

    function doMove(i, sym) {
        session.board[i] = sym;
        session.history.push(i);
        render();
        const win = checkWin(session.board, sym);
        if (win) {
            session.active = false;
            win.forEach(idx => document.getElementById('board').children[idx].classList.add('winner'));
            setStatus(sym === settings.playerSide ? "–ü–û–ë–ï–î–ê!" : "–ë–û–¢ –í–´–ò–ì–†–ê–õ");
            return;
        }
        if (!session.board.includes(null)) { session.active = false; setStatus("–ù–ò–ß–¨–Ø"); return; }
        session.turn = (session.turn === 'X') ? 'O' : 'X';
        checkTurn();
    }

    function botMove() {
        if (!session.active) return;
        let idx = (settings.diff === 'god') ? findGodMove() : findBestLogic();
        if (settings.diff === 'easy' && Math.random() < 0.7) idx = randomEmpty();
        if (idx !== null) doMove(idx, session.turn);
    }

    function findBestLogic() {
        // –ë–∞–∑–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è NORM: –∞—Ç–∞–∫–∞ –∏ –∑–∞—â–∏—Ç–∞
        let win = findWinMove(session.turn); if (win !== null) return win;
        let block = findWinMove(settings.playerSide); if (block !== null) return block;
        return randomEmpty();
    }

    function findWinMove(sym) {
        for(let i=0; i<session.board.length; i++) {
            if(!session.board[i]) {
                let b = [...session.board]; b[i] = sym;
                if(checkWin(b, sym)) return i;
            }
        }
        return null;
    }

    function findGodMove() {
        // 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –ø–æ–±–µ–¥—É –∏–ª–∏ –±–ª–æ–∫
        let win = findWinMove(session.turn); if (win !== null) return win;
        let block = findWinMove(settings.playerSide); if (block !== null) return block;

        // 2. –ï—Å–ª–∏ –ø–æ–ª–µ 3—Ö3 –∏ —ç—Ç–æ –Ω–∞—á–∞–ª–æ - —é–∑–∞–µ–º –º–∏–Ω–∏–º–∞–∫—Å
        if (settings.size === 3 && session.board.filter(x => x).length < 2) {
            return minimax(session.board, 0, true, -Infinity, Infinity).index;
        }

        // 3. –°–∏—Å—Ç–µ–º–∞ –≤–µ—Å–æ–≤ —Å —É—á–µ—Ç–æ–º —Ç–∞–∫—Ç–∏–∫–∏
        let weights = Array(session.board.length).fill(0);
        let center = Math.floor(settings.size / 2);

        session.winLines.forEach(line => {
            let me = line.filter(idx => session.board[idx] === session.turn).length;
            let op = line.filter(idx => session.board[idx] === settings.playerSide).length;
            if (me > 0 && op > 0) return;
            
            line.forEach(idx => {
                if (!session.board[idx]) {
                    let score = 1 + (me * 2) + (op * 1.5);
                    
                    // –£—á–µ—Ç —Ç–∞–∫—Ç–∏–∫–∏
                    if (session.tactic === 'center') {
                        let dist = Math.abs(Math.floor(idx/settings.size) - center) + Math.abs((idx%settings.size) - center);
                        score += (settings.size - dist);
                    } else if (session.tactic === 'corners') {
                        let isCorner = [0, settings.size-1, settings.size*(settings.size-1), settings.size*settings.size-1].includes(idx);
                        if (isCorner) score += 3;
                    }
                    
                    weights[idx] += score + (Math.random() * 0.5); // –†–∞–Ω–¥–æ–º–Ω–∞—è –¥–æ–±–∞–≤–∫–∞ –¥–ª—è –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç–∏
                }
            });
        });

        let maxW = -1, best = [];
        weights.forEach((w, i) => {
            if (session.board[i]) return;
            if (w > maxW) { maxW = w; best = [i]; }
            else if (Math.abs(w - maxW) < 0.1) best.push(i);
        });
        return best[Math.floor(Math.random() * best.length)];
    }

    function minimax(board, depth, isMax, alpha, beta) {
        const avail = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
        const botS = session.botSide; const plS = settings.playerSide;
        if (checkWin(board, plS)) return { score: -10 + depth };
        if (checkWin(board, botS)) return { score: 10 - depth };
        if (avail.length === 0) return { score: 0 };
        let moves = [];
        for (let i = 0; i < avail.length; i++) {
            let move = { index: avail[i] };
            board[avail[i]] = isMax ? botS : plS;
            let res = minimax(board, depth + 1, !isMax, alpha, beta);
            move.score = res.score; board[avail[i]] = null;
            moves.push(move);
            if (isMax) { alpha = Math.max(alpha, move.score); if (beta <= alpha) break; }
            else { beta = Math.min(beta, move.score); if (beta <= alpha) break; }
        }
        let bestIdx = 0;
        if (isMax) {
            let bs = -Infinity; for (let i=0; i<moves.length; i++) { if(moves[i].score > bs) { bs=moves[i].score; bestIdx=i; } }
        } else {
            let bs = Infinity; for (let i=0; i<moves.length; i++) { if(moves[i].score < bs) { bs=moves[i].score; bestIdx=i; } }
        }
        return moves[bestIdx];
    }

    function randomEmpty() {
        const empty = session.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
        return empty.length ? empty[Math.floor(Math.random() * empty.length)] : null;
    }

    function getHint() {
        if (!session.active) return;
        const idx = findGodMove(); if(idx === null) return;
        const cell = document.getElementById('board').children[idx];
        cell.classList.add('hint'); setTimeout(() => cell.classList.remove('hint'), 800);
    }

    function generateLines(s, w) {
        let lines = [];
        for (let r = 0; r < s; r++) { for (let c = 0; c <= s - w; c++) { let l = []; for (let k = 0; k < w; k++) l.push(r * s + (c + k)); lines.push(l); } }
        for (let c = 0; c < s; c++) { for (let r = 0; r <= s - w; r++) { let l = []; for (let k = 0; k < w; k++) l.push((r + k) * s + c); lines.push(l); } }
        for (let r = 0; r <= s - w; r++) { for (let c = 0; c <= s - w; c++) { let l1 = [], l2 = []; for (let k = 0; k < w; k++) { l1.push((r + k) * s + (c + k)); l2.push((r + k) * s + (c + w - 1 - k)); } lines.push(l1); lines.push(l2); } }
        return lines;
    }

    function checkWin(b, sym) { for (let line of session.winLines) { if (line.every(i => b[i] === sym)) return line; } return null; }
    function setStatus(t) { document.getElementById('status').innerText = t; }
    drawEmpty();
</script>
</body>
</html>
